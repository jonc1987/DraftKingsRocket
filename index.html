<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Draft Rocket</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Poppins:wght@400;500&display=swap');

      :root {
        --progress: 0;
        --stage-hue: 210;
        --glow-strength: 0.2;
        --pulse-progress: 0;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(18px, 3vw, 40px);
        background: radial-gradient(circle at 20% 20%, #020514, #01020b 55%, #000000);
        font-family: 'Poppins', 'Orbitron', system-ui, sans-serif;
        color: #eaf9ff;
      }

      body::before {
        content: '';
        position: fixed;
        inset: 0;
        background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="140" height="140" viewBox="0 0 140 140"%3E%3Ccircle cx="12" cy="18" r="1" fill="rgba(255,255,255,0.35)"/%3E%3Ccircle cx="88" cy="60" r="1" fill="rgba(255,255,255,0.35)"/%3E%3Ccircle cx="120" cy="18" r="1" fill="rgba(255,255,255,0.25)"/%3E%3Ccircle cx="60" cy="120" r="1" fill="rgba(255,255,255,0.2)"/%3E%3C/svg%3E');
        opacity: 0.4;
        pointer-events: none;
      }

      .app-shell {
        width: min(1100px, 100%);
        display: flex;
        flex-direction: column;
        gap: clamp(16px, 3vw, 28px);
      }

      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 18px;
        text-transform: uppercase;
        letter-spacing: 0.16em;
      }

      .mode-switcher,
      .section-switcher {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(6, 22, 35, 0.6);
        border: 1px solid rgba(110, 255, 236, 0.18);
        box-shadow: inset 0 0 18px rgba(0, 255, 204, 0.08);
      }

      .mode-button,
      .section-button {
        flex: 0 0 auto;
        padding: 10px 18px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: rgba(12, 32, 46, 0.65);
        color: rgba(230, 249, 255, 0.85);
        font-size: 13px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.18s ease, box-shadow 0.18s ease;
      }

      .mode-button:hover,
      .section-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(0, 255, 204, 0.2);
      }

      .mode-button.active,
      .section-button.active {
        background: linear-gradient(135deg, #00ffc8, #00aaff);
        color: #002033;
        box-shadow: 0 16px 30px rgba(0, 255, 222, 0.28);
      }

      .section-wrapper {
        display: flex;
        flex-direction: column;
        gap: clamp(22px, 4vw, 32px);
      }

      .section-panel {
        display: none;
        flex-direction: column;
        gap: clamp(20px, 3vw, 30px);
      }

      .section-panel.active {
        display: flex;
      }

      .section-heading-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 16px;
      }

      .section-heading {
        margin: 0;
        font-size: clamp(20px, 3vw, 26px);
        color: #6ef3ff;
        font-weight: 600;
        letter-spacing: 0.18em;
        text-transform: uppercase;
      }

      .mode-wrapper {
        display: flex;
        flex-direction: column;
        gap: clamp(18px, 3vw, 26px);
      }

      .mode-panel {
        display: none;
      }

      .mode-panel.active {
        display: block;
      }

      .title {
        font-size: clamp(22px, 3vw, 28px);
        color: #6ef3ff;
        font-weight: 600;
      }

      .balance {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(16px, 2.5vw, 20px);
        color: rgba(255, 255, 255, 0.85);
      }

      .main-layout {
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(260px, 1fr);
        gap: clamp(20px, 3vw, 36px);
      }

      .device-shell {
        position: relative;
        padding: clamp(14px, 2vw, 22px);
        border-radius: 40px;
        background: linear-gradient(145deg, rgba(10, 18, 32, 0.85), rgba(1, 3, 10, 0.95));
        border: 1px solid rgba(108, 255, 255, 0.18);
        box-shadow: 0 45px 90px rgba(0, 0, 0, 0.65);
      }

      .device-shell::before,
      .device-shell::after {
        content: '';
        position: absolute;
        inset: 12px;
        border-radius: 32px;
        pointer-events: none;
      }

      .device-shell::before {
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .device-shell::after {
        box-shadow: inset 0 0 60px rgba(0, 255, 229, 0.05);
      }

      .stage {
        position: relative;
        aspect-ratio: 16 / 7.5;
        width: 100%;
        border-radius: 26px;
        overflow: hidden;
        background: linear-gradient(
          180deg,
          hsla(var(--stage-hue), 92%, 12%, 0.85),
          rgba(0, 0, 0, 0.92)
        );
        border: 1px solid rgba(80, 255, 226, 0.18);
        box-shadow: inset 0 8px 30px rgba(0, 0, 0, 0.8);
      }

      .stage::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(0deg, rgba(8, 14, 24, 0.7) 0%, rgba(8, 14, 24, 0.1) 55%, rgba(8, 14, 24, 0.7) 100%);
        pointer-events: none;
      }

      .scroll-field {
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
          to top,
          transparent,
          transparent 54px,
          rgba(255, 255, 255, 0.05) 56px
        );
        opacity: 0.45;
        transform: translateY(0);
        animation: drift 18s linear infinite;
      }

      @keyframes drift {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(-56px);
        }
      }

      .horizon-line {
        position: absolute;
        bottom: 14%;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(0, 255, 158, 0.55), rgba(255, 255, 255, 0));
        box-shadow: 0 0 14px rgba(0, 255, 200, 0.35);
      }

      .path-wrapper {
        position: absolute;
        inset: 12% 9% 18% 9%;
      }

      svg.flight-path {
        width: 100%;
        height: 100%;
      }

      .path-guide {
        fill: none;
        stroke: rgba(70, 150, 255, 0.28);
        stroke-width: 2;
        stroke-dasharray: 10 16;
      }

      .path-progress {
        fill: none;
        stroke: rgba(110, 255, 224, 0.85);
        stroke-width: 3;
        stroke-linecap: round;
        stroke-dasharray: 1;
        stroke-dashoffset: 1;
        filter: drop-shadow(0 0 12px rgba(110, 255, 224, 0.45));
        transition: stroke-dashoffset 0.1s linear;
      }

      .track-glow {
        position: absolute;
        inset: 20% 12% 24% 12%;
        background: radial-gradient(
          circle at calc(var(--progress) * 100%) 55%,
          rgba(94, 255, 224, var(--glow-strength)),
          rgba(94, 255, 224, 0) 65%
        );
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .pulse-stage {
        position: relative;
        overflow: hidden;
      }

      .pulse-track {
        position: absolute;
        inset: 44% 11%;
        height: 12%;
        background: linear-gradient(90deg, rgba(12, 40, 58, 0.4), rgba(40, 142, 134, 0.4));
        border-radius: 40px;
        box-shadow: inset 0 0 18px rgba(0, 255, 204, 0.18);
      }

      .pulse-track::after {
        content: '';
        position: absolute;
        inset: calc(50% - 2px) 4%;
        background: linear-gradient(90deg, rgba(52, 255, 214, 0), rgba(52, 255, 214, 0.6), rgba(52, 255, 214, 0));
        border-radius: 20px;
        box-shadow: 0 0 18px rgba(94, 255, 224, 0.35);
      }

      .pulse-line {
        position: absolute;
        top: 50%;
        left: 0;
        width: 22px;
        height: 22px;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background: radial-gradient(circle, #ffffff 0%, #7cffea 55%, rgba(124, 255, 234, 0) 80%);
        box-shadow: 0 0 16px rgba(94, 255, 224, 0.55), 0 0 34px rgba(0, 198, 255, 0.3);
        transition: filter 0.2s ease;
      }

      .pulse-glow {
        position: absolute;
        top: 50%;
        left: 0;
        width: 280px;
        height: 280px;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, rgba(94, 255, 224, 0.35), rgba(94, 255, 224, 0));
        filter: blur(14px);
        pointer-events: none;
        opacity: 0.35;
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      .pulse-stage.live .pulse-line {
        animation: pulse-hum 0.6s ease-in-out infinite alternate;
      }

      @keyframes pulse-hum {
        from {
          filter: drop-shadow(0 0 12px rgba(94, 255, 224, 0.6));
        }
        to {
          filter: drop-shadow(0 0 18px rgba(0, 198, 255, 0.5));
        }
      }

      .pulse-stage.overloaded .pulse-line {
        animation: pulse-flicker 0.16s linear 4;
      }

      @keyframes pulse-flicker {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.2;
        }
      }

      .pulse-stage.overloaded {
        animation: pulse-fade 0.6s ease forwards;
      }

      @keyframes pulse-fade {
        0% {
          opacity: 1;
          filter: none;
        }
        100% {
          opacity: 0.3;
          filter: blur(2px);
        }
      }

      .mind-stage {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: clamp(14px, 3vw, 22px);
        padding: clamp(36px, 6vw, 72px);
        overflow: hidden;
      }

      .mind-stage .scroll-field {
        opacity: 0.25;
      }

      .mind-stage .mind-glitch {
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
            0deg,
            rgba(94, 255, 224, 0.08),
            rgba(94, 255, 224, 0.08) 2px,
            rgba(6, 18, 28, 0.05) 2px,
            rgba(6, 18, 28, 0.05) 4px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(94, 255, 224, 0.04),
            rgba(94, 255, 224, 0.04) 3px,
            transparent 3px,
            transparent 6px
          );
        opacity: 0;
        mix-blend-mode: screen;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .mind-stage .mind-glitch,
      .mind-stage .scroll-field {
        z-index: 0;
      }

      .mind-stage .ai-face,
      .mind-stage .mind-mood,
      .mind-stage .multiplier-readout,
      .mind-stage .potential-readout,
      .mind-stage .history {
        position: relative;
        z-index: 2;
      }

      .mind-stage.near-flip .mind-glitch {
        opacity: 0.35;
        animation: mind-glitch 0.4s steps(2) infinite;
      }

      @keyframes mind-glitch {
        0% {
          transform: translate(0, 0);
        }
        50% {
          transform: translate(1px, -1px);
        }
        100% {
          transform: translate(-1px, 1px);
        }
      }

      .ai-face {
        position: relative;
        width: clamp(160px, 28vw, 240px);
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 40px rgba(94, 255, 224, 0.35), inset 0 0 30px rgba(0, 0, 0, 0.65);
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.2), rgba(6, 10, 20, 0.9));
        transition: box-shadow 0.4s ease, transform 0.4s ease;
      }

      .ai-face::after {
        content: '';
        position: absolute;
        inset: 14%;
        border-radius: 50%;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 22px rgba(0, 0, 0, 0.6);
      }

      .ai-emotion {
        font-size: clamp(42px, 6vw, 64px);
        filter: drop-shadow(0 0 14px rgba(0, 0, 0, 0.45));
        transition: transform 0.3s ease;
      }

      .mind-stage.mood-calm .ai-face {
        background: radial-gradient(circle at 28% 28%, rgba(140, 228, 255, 0.5), rgba(0, 18, 40, 0.9));
        box-shadow: 0 0 40px rgba(116, 208, 255, 0.45), inset 0 0 30px rgba(3, 15, 28, 0.9);
      }

      .mind-stage.mood-thinking .ai-face {
        background: radial-gradient(circle at 30% 30%, rgba(255, 220, 120, 0.6), rgba(20, 12, 0, 0.9));
        box-shadow: 0 0 40px rgba(255, 215, 130, 0.45), inset 0 0 30px rgba(20, 12, 0, 0.88);
      }

      .mind-stage.mood-worried .ai-face {
        background: radial-gradient(circle at 32% 32%, rgba(255, 150, 84, 0.6), rgba(25, 6, 0, 0.9));
        box-shadow: 0 0 40px rgba(255, 150, 84, 0.55), inset 0 0 30px rgba(25, 6, 0, 0.88);
      }

      .mind-stage.mood-erratic .ai-face {
        background: radial-gradient(circle at 35% 35%, rgba(255, 90, 90, 0.65), rgba(28, 0, 0, 0.92));
        box-shadow: 0 0 40px rgba(255, 90, 90, 0.62), inset 0 0 30px rgba(28, 0, 0, 0.92);
      }

      .mind-stage.mood-erratic .ai-emotion {
        animation: mind-erratic 0.4s ease-in-out infinite alternate;
      }

      @keyframes mind-erratic {
        from {
          transform: translate(-2px, -2px) scale(1.02);
        }
        to {
          transform: translate(2px, 2px) scale(0.98);
        }
      }

      .mind-mood {
        font-size: clamp(16px, 2.3vw, 20px);
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.75);
      }

      .mind-stage .potential-readout {
        top: 24px;
        right: 24px;
      }

      .history {
        position: absolute;
        left: 18px;
        top: 18px;
        display: grid;
        gap: 8px;
        font-size: 13px;
        font-family: 'Orbitron', sans-serif;
        color: rgba(255, 255, 255, 0.72);
        list-style: none;
        margin: 0;
        padding: 0;
      }

      .history li {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .history li::before {
        content: '';
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: currentColor;
        box-shadow: 0 0 8px currentColor;
      }

      .history .win {
        color: #5dffbe;
      }

      .history .loss {
        color: #ff8375;
      }

      .history .placeholder {
        color: rgba(255, 255, 255, 0.35);
      }

      .history .placeholder::before {
        box-shadow: none;
      }

      .multiplier-readout {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 10px;
        text-align: center;
      }

      #multiplier,
      #pulseMultiplier,
      #mindMultiplier {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(42px, 6vw, 64px);
        text-shadow: 0 0 18px rgba(90, 255, 221, 0.6);
      }

      #roundResult,
      #pulseRoundResult,
      #mindRoundResult {
        font-size: clamp(16px, 2.5vw, 22px);
        color: rgba(255, 255, 255, 0.82);
      }

      #roundResult.win,
      #pulseRoundResult.win,
      #mindRoundResult.win {
        color: #64ffd2;
        text-shadow: 0 0 16px rgba(100, 255, 210, 0.55);
      }

      #roundResult.loss,
      #pulseRoundResult.loss,
      #mindRoundResult.loss {
        color: #ff8a78;
        text-shadow: 0 0 12px rgba(255, 110, 110, 0.45);
      }

      .potential-readout {
        position: absolute;
        right: 26px;
        top: 26px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.65);
      }

      .rocket {
        position: absolute;
        width: 46px;
        height: 46px;
        left: 8%;
        bottom: 18%;
        transform: translate(-50%, 0) rotate(-6deg);
        transition: transform 0.18s ease;
      }

      .stage.idle .rocket {
        animation: idle-sway 3s ease-in-out infinite;
      }

      @keyframes idle-sway {
        0%,
        100% {
          transform: translate(-50%, 0) rotate(-6deg) translateY(0);
        }
        50% {
          transform: translate(-50%, 0) rotate(-3deg) translateY(-3px);
        }
      }

      .rocket-body {
        width: 26px;
        height: 36px;
        margin: 0 auto;
        background: linear-gradient(180deg, #fefefe 0%, #8fc1ff 70%, #ffb678 100%);
        border-radius: 16px 16px 10px 10px;
        border: 2px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 0 14px rgba(255, 255, 255, 0.4);
      }

      .rocket-tip {
        position: absolute;
        top: -10px;
        left: 50%;
        width: 12px;
        height: 16px;
        background: linear-gradient(180deg, #92c8ff, #356eff);
        border-radius: 50% 50% 40% 40%;
        transform: translateX(-50%);
        border: 2px solid rgba(255, 255, 255, 0.5);
      }

      .rocket-fin {
        position: absolute;
        bottom: 8px;
        width: 10px;
        height: 16px;
        background: linear-gradient(180deg, #ff8460, #ffb38a);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.5);
      }

      .rocket-fin.left {
        left: 2px;
        transform: rotate(-18deg);
      }

      .rocket-fin.right {
        right: 2px;
        transform: rotate(18deg);
      }

      .rocket-flame {
        position: absolute;
        bottom: -14px;
        left: 50%;
        width: 12px;
        height: 18px;
        transform: translateX(-50%);
        border-radius: 50% 50% 60% 60%;
        background: radial-gradient(circle at 50% 10%, #fff, #ffd84e 60%, rgba(255, 92, 0, 0.8));
        animation: flame 0.18s ease-in-out infinite;
        filter: drop-shadow(0 0 10px rgba(255, 163, 72, 0.7));
      }

      @keyframes flame {
        0%,
        100% {
          transform: translateX(-50%) scaleY(0.9);
        }
        50% {
          transform: translateX(-50%) scaleY(1.1);
        }
      }

      .stage.danger {
        animation: danger-glow 0.6s ease-in-out infinite alternate;
      }

      @keyframes danger-glow {
        from {
          box-shadow: inset 0 8px 30px rgba(0, 0, 0, 0.8), 0 0 0 rgba(255, 94, 94, 0.2);
        }
        to {
          box-shadow: inset 0 8px 30px rgba(0, 0, 0, 0.8), 0 0 30px rgba(255, 94, 94, 0.4);
        }
      }

      .stage.exploded {
        animation: shake 0.35s linear;
      }

      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        20% {
          transform: translateX(-6px);
        }
        40% {
          transform: translateX(4px);
        }
        60% {
          transform: translateX(-4px);
        }
        80% {
          transform: translateX(3px);
        }
        100% {
          transform: translateX(0);
        }
      }

      .control-panel {
        display: flex;
        flex-direction: column;
        gap: 18px;
        padding: clamp(20px, 3vw, 28px);
        border-radius: 26px;
        border: 1px solid rgba(110, 255, 236, 0.16);
        background: rgba(3, 9, 20, 0.88);
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.5);
      }

      .control-panel h2 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.75);
      }

      label {
        display: block;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 8px;
      }

      input[type='number'] {
        width: 100%;
        padding: 14px 16px;
        border-radius: 14px;
        border: 1px solid rgba(126, 255, 234, 0.32);
        background: rgba(255, 255, 255, 0.08);
        color: #eaf9ff;
        font-size: 18px;
        font-family: 'Orbitron', sans-serif;
      }

      input[type='number']:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(94, 255, 224, 0.3);
      }

      .button-row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      button {
        flex: 1;
        border: none;
        border-radius: 16px;
        padding: 14px;
        font-family: 'Orbitron', sans-serif;
        font-size: 15px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        cursor: pointer;
        transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
      }

      button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
        transform: none !important;
        box-shadow: none !important;
      }

      .launch {
        background: linear-gradient(135deg, #00ffc8, #00aaff);
        color: #002033;
        box-shadow: 0 18px 40px rgba(0, 255, 222, 0.35);
      }

      .cashout {
        background: linear-gradient(135deg, #ffc966, #ff6f6f);
        color: #1d0505;
        box-shadow: 0 18px 40px rgba(255, 122, 122, 0.35);
      }

      .launch:not(:disabled):hover,
      .cashout:not(:disabled):hover {
        transform: translateY(-2px);
        filter: brightness(1.05);
      }

      .risk-copy,
      .status {
        font-size: 13px;
        line-height: 1.5;
        color: rgba(255, 255, 255, 0.66);
      }

      .status {
        min-height: 40px;
        font-size: 14px;
      }

      .panel-meta {
        display: flex;
        justify-content: space-between;
        font-family: 'Orbitron', sans-serif;
        color: rgba(255, 255, 255, 0.6);
        font-size: 13px;
      }

      .panel-meta span strong {
        color: #6effde;
      }

      .card-games-wrapper {
        display: flex;
        flex-direction: column;
        gap: clamp(20px, 3vw, 28px);
      }

      .card-panel {
        display: none;
        flex-direction: column;
        gap: clamp(18px, 3vw, 24px);
      }

      .card-panel.active {
        display: flex;
      }

      .card-intro {
        margin: 0;
        color: rgba(255, 255, 255, 0.68);
        letter-spacing: 0.14em;
        text-transform: uppercase;
        font-size: 13px;
      }

      .card-grid {
        display: grid;
        gap: clamp(14px, 2.5vw, 22px);
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .card-tile {
        position: relative;
        padding: clamp(18px, 2.6vw, 26px);
        border-radius: 18px;
        border: 1px solid rgba(110, 255, 236, 0.16);
        background: rgba(6, 20, 32, 0.82);
        color: rgba(234, 249, 255, 0.88);
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease, background 0.2s ease;
        overflow: hidden;
      }

      .card-tile::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: radial-gradient(circle at 30% 30%, rgba(110, 255, 236, 0.18), rgba(110, 255, 236, 0));
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }

      .card-tile .card-name {
        display: block;
        font-size: clamp(14px, 2vw, 16px);
        margin-bottom: 10px;
      }

      .card-tile .card-meta {
        display: block;
        font-size: 11px;
        letter-spacing: 0.22em;
        color: rgba(255, 255, 255, 0.58);
      }

      .card-tile:hover:not(:disabled) {
        transform: translateY(-4px);
        border-color: rgba(110, 255, 236, 0.4);
        box-shadow: 0 22px 40px rgba(0, 255, 222, 0.22);
        background: rgba(12, 44, 60, 0.9);
      }

      .card-tile:hover:not(:disabled)::after {
        opacity: 1;
      }

      .card-tile:disabled,
      .card-tile.coming-soon {
        cursor: not-allowed;
        color: rgba(255, 255, 255, 0.35);
        border-color: rgba(110, 255, 236, 0.08);
        background: rgba(3, 12, 20, 0.6);
      }

      .card-game-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }

      .card-game-title {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(18px, 2.4vw, 22px);
        letter-spacing: 0.22em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.75);
      }

      .ghost-button {
        border-radius: 999px;
        border: 1px solid rgba(110, 255, 236, 0.32);
        background: rgba(6, 20, 32, 0.5);
        color: rgba(234, 249, 255, 0.82);
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 0.18em;
        padding: 10px 18px;
        text-transform: uppercase;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      }

      .ghost-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 16px 32px rgba(0, 255, 222, 0.22);
        border-color: rgba(110, 255, 236, 0.55);
      }

      .binary-stage {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: clamp(18px, 3vw, 28px);
        padding: clamp(24px, 4vw, 40px);
      }

      .binary-stage::after {
        content: '';
        position: absolute;
        inset: 12%;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: inset 0 0 30px rgba(110, 255, 236, 0.12);
        pointer-events: none;
      }

      .binary-stage.live::after {
        box-shadow: inset 0 0 40px rgba(110, 255, 236, 0.28);
      }

      .binary-hand {
        position: relative;
        display: flex;
        flex-wrap: wrap;
        gap: clamp(12px, 2vw, 18px);
        justify-content: center;
        z-index: 2;
      }

      .binary-card {
        position: relative;
        width: clamp(96px, 15vw, 120px);
        aspect-ratio: 3 / 4;
        border-radius: 18px;
        border: 1px solid rgba(110, 255, 236, 0.22);
        background: linear-gradient(160deg, rgba(8, 24, 36, 0.95), rgba(2, 10, 20, 0.85));
        color: rgba(234, 249, 255, 0.9);
        padding: 16px 14px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: stretch;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
      }

      .binary-card:not(.placeholder) {
        cursor: pointer;
      }

      .binary-card:not(.placeholder):hover {
        transform: translateY(-4px);
        box-shadow: 0 24px 44px rgba(0, 255, 222, 0.24);
        border-color: rgba(110, 255, 236, 0.4);
      }

      .binary-card.active {
        border-color: rgba(110, 255, 236, 0.65);
        box-shadow: 0 0 18px rgba(110, 255, 236, 0.5);
      }

      .binary-card .binary-label {
        font-size: 11px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.55);
      }

      .binary-card .binary-value {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(20px, 3vw, 26px);
        text-align: center;
        letter-spacing: 0.12em;
        color: rgba(110, 255, 236, 0.95);
      }

      .binary-card .binary-bits {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        margin-top: auto;
      }

      .binary-bit {
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        border: 1px solid rgba(110, 255, 236, 0.25);
        background: rgba(4, 18, 26, 0.8);
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(16px, 2.8vw, 20px);
        transition: transform 0.18s ease, box-shadow 0.18s ease, border 0.18s ease;
      }

      .binary-card.active .binary-bit {
        border-color: rgba(110, 255, 236, 0.55);
      }

      .binary-card.active .binary-bit:hover {
        transform: translateY(-2px);
        box-shadow: 0 16px 28px rgba(0, 255, 222, 0.22);
      }

      .binary-bit.flipped {
        border-color: rgba(255, 215, 120, 0.75);
        box-shadow: 0 0 18px rgba(255, 215, 120, 0.4);
        background: rgba(40, 26, 4, 0.85);
      }

      .binary-placeholder {
        padding: 28px 24px;
        border-radius: 18px;
        border: 1px dashed rgba(110, 255, 236, 0.28);
        background: rgba(2, 12, 22, 0.6);
        letter-spacing: 0.18em;
        text-transform: uppercase;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.45);
      }

      .binary-target {
        position: relative;
        z-index: 2;
        font-family: 'Orbitron', sans-serif;
        letter-spacing: 0.22em;
        text-transform: uppercase;
        font-size: clamp(12px, 1.8vw, 14px);
        color: rgba(255, 255, 255, 0.65);
        text-align: center;
      }

      .card-controls h2 {
        letter-spacing: 0.2em;
      }

      @media (max-width: 960px) {
        .main-layout {
          grid-template-columns: 1fr;
        }

        .device-shell {
          margin: 0 auto;
        }
      }

      @media (max-width: 600px) {
        .top-bar {
          flex-direction: column;
          align-items: flex-start;
        }

        .mode-switcher {
          width: 100%;
          justify-content: center;
        }

        .button-row {
          flex-direction: column;
        }

        button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header class="top-bar">
        <div class="title" id="sectionTitle">NeonArc Casino ¬∑ Rocket Line</div>
        <nav class="section-switcher" aria-label="Game sections">
          <button class="section-button active" data-section="skill" type="button">Skill Games</button>
          <button class="section-button" data-section="card" type="button">Card Games</button>
        </nav>
        <div class="balance">Balance: $<span id="balance">1,000.00</span></div>
      </header>
      <main class="section-wrapper">
        <section class="section-panel active" id="skillGamesSection" aria-label="Skill Games">
          <div class="section-heading-row">
            <h2 class="section-heading">Skill Games</h2>
            <nav class="mode-switcher" aria-label="Skill game modes">
              <button class="mode-button active" data-mode="rocket" type="button">Rocket Mode</button>
              <button class="mode-button" data-mode="pulse" type="button">Pulse Cash</button>
              <button class="mode-button" data-mode="mind" type="button">Mind Bet</button>
            </nav>
          </div>
          <div class="mode-wrapper">
            <section class="mode-panel active" id="rocketMode" aria-label="Rocket Mode">
          <div class="main-layout">
            <div class="device-shell">
              <div class="stage idle" id="rocketStage">
                <div class="scroll-field"></div>
                <div class="path-wrapper">
                  <svg class="flight-path" viewBox="0 0 600 260" preserveAspectRatio="none">
                    <path
                      id="pathGuide"
                      class="path-guide"
                      d="M40 210 Q 260 160 540 130"
                    ></path>
                    <path
                      id="pathProgress"
                      class="path-progress"
                      d="M40 210 Q 260 160 540 130"
                    ></path>
                  </svg>
                </div>
                <div class="track-glow" id="rocketTrackGlow"></div>
                <ul class="history" id="history"></ul>
                <div class="potential-readout" id="potential">Potential: $0.00</div>
                <div class="multiplier-readout">
                  <div id="multiplier">1.00x</div>
                  <div id="roundResult">Enter a bet to play.</div>
                </div>
                <div class="horizon-line"></div>
                <div class="rocket" id="rocket">
                  <div class="rocket-tip"></div>
                  <div class="rocket-body"></div>
                  <div class="rocket-fin left"></div>
                  <div class="rocket-fin right"></div>
                  <div class="rocket-flame"></div>
                </div>
              </div>
            </div>
            <aside class="control-panel">
              <h2>Controls</h2>
              <div>
                <label for="bet">Bet Amount</label>
                <input type="number" id="bet" min="1" step="1" value="25" />
              </div>
              <div class="panel-meta">
                <span>Risk Tier: <strong id="riskTag">Balanced</strong></span>
                <span>Round: <strong id="roundTag">Idle</strong></span>
              </div>
              <div class="button-row">
                <button class="launch" id="launchBtn">Launch</button>
                <button class="cashout" id="cashOutBtn" disabled>Cash Out</button>
              </div>
              <div class="risk-copy" id="riskCopy"></div>
              <div class="status" id="status">Rocket idling on the pad.</div>
            </aside>
          </div>
        </section>

        <section class="mode-panel" id="pulseMode" aria-label="Pulse Cash Mode">
          <div class="main-layout">
            <div class="device-shell">
              <div class="stage idle pulse-stage" id="pulseStage">
                <div class="scroll-field"></div>
                <div class="pulse-track">
                  <div class="pulse-glow" id="pulseGlow"></div>
                  <div class="pulse-line" id="pulseLine"></div>
                </div>
                <ul class="history" id="pulseHistory"></ul>
                <div class="potential-readout" id="pulsePotential">Potential: $0.00</div>
                <div class="multiplier-readout">
                  <div id="pulseMultiplier">1.00x</div>
                  <div id="pulseRoundResult">Enter a bet to play.</div>
                </div>
              </div>
            </div>
            <aside class="control-panel">
              <h2>Pulse Console</h2>
              <div>
                <label for="pulseBet">Bet Amount</label>
                <input type="number" id="pulseBet" min="1" step="1" value="25" />
              </div>
              <div class="panel-meta">
                <span>Risk Tier: <strong id="pulseRiskTag">Balanced</strong></span>
                <span>Round: <strong id="pulseRoundTag">Idle</strong></span>
              </div>
              <div class="button-row">
                <button class="launch" id="pulseLaunchBtn">Launch Pulse</button>
                <button class="cashout" id="pulseCashBtn" disabled>Cash Out</button>
              </div>
              <div class="risk-copy" id="pulseRiskCopy"></div>
              <div class="status" id="pulseStatus">Pulse core stable.</div>
            </aside>
          </div>
        </section>

        <section class="mode-panel" id="mindMode" aria-label="Mind Bet Mode">
          <div class="main-layout">
            <div class="device-shell">
              <div class="stage idle mind-stage" id="mindStage">
                <div class="scroll-field"></div>
                <div class="mind-glitch" id="mindGlitch"></div>
                <div class="ai-face" id="aiFace">
                  <div class="ai-emotion" id="aiEmotion">üòå</div>
                </div>
                <div class="mind-mood" id="mindMood">AI calm and observant.</div>
                <ul class="history" id="mindHistory"></ul>
                <div class="potential-readout" id="mindPotential">Potential: $0.00</div>
                <div class="multiplier-readout">
                  <div id="mindMultiplier">1.00x</div>
                  <div id="mindRoundResult">Sync a wager to begin.</div>
                </div>
              </div>
            </div>
            <aside class="control-panel">
              <h2>Mind Console</h2>
              <div>
                <label for="mindBet">Bet Amount</label>
                <input type="number" id="mindBet" min="1" step="1" value="25" />
              </div>
              <div class="panel-meta">
                <span>Signal Read: <strong id="mindSignalTag">Calibrating</strong></span>
                <span>Round: <strong id="mindRoundTag">Idle</strong></span>
              </div>
              <div class="button-row">
                <button class="launch" id="mindStartBtn">Start Mind Bet</button>
                <button class="cashout" id="mindCashBtn" disabled>Cash Out</button>
              </div>
              <div class="risk-copy" id="mindInsight"></div>
              <div class="status" id="mindStatus">Interface standing by.</div>
            </aside>
          </div>
        </section>
      </div>
    </section>
    <section class="section-panel" id="cardGamesSection" aria-label="Card Games">
      <div class="section-heading-row">
        <h2 class="section-heading">Card Games</h2>
      </div>
      <div class="card-games-wrapper">
        <div class="card-panel active" id="cardLobby">
          <p class="card-intro">
            Select a NeonArc card experience. Binary Poker is live; future decks are warming up.
          </p>
          <div class="card-grid">
            <button class="card-tile card-game-tile" data-game="binaryPoker" type="button">
              <span class="card-name">Binary Poker</span>
              <span class="card-meta">Live ¬∑ Flip a bit</span>
            </button>
            <button class="card-tile coming-soon" type="button" disabled>
              <span class="card-name">StackJack</span>
              <span class="card-meta">Coming Soon</span>
            </button>
            <button class="card-tile coming-soon" type="button" disabled>
              <span class="card-name">Echo Hand</span>
              <span class="card-meta">Coming Soon</span>
            </button>
            <button class="card-tile coming-soon" type="button" disabled>
              <span class="card-name">Fuse</span>
              <span class="card-meta">Coming Soon</span>
            </button>
            <button class="card-tile coming-soon" type="button" disabled>
              <span class="card-name">Perception</span>
              <span class="card-meta">Coming Soon</span>
            </button>
          </div>
        </div>
        <div class="card-panel" id="binaryPokerGame">
          <div class="card-game-header">
            <button class="ghost-button" id="cardBackBtn" type="button">‚Üê Back to Card Lobby</button>
            <div class="card-game-title">Binary Poker</div>
          </div>
          <div class="main-layout card-layout">
            <div class="device-shell">
              <div class="stage idle binary-stage" id="binaryStage">
                <div class="scroll-field"></div>
                <div class="binary-hand" id="binaryHand">
                  <div class="binary-placeholder">Deal a hand to reveal five binary cards.</div>
                </div>
                <div class="binary-target" id="binaryTarget">Target encoded. Flip a bit or lock in.</div>
              </div>
            </div>
            <aside class="control-panel card-controls">
              <h2>Binary Poker</h2>
              <div>
                <label for="binaryBet">Bet Amount</label>
                <input type="number" id="binaryBet" min="1" step="1" value="20" />
              </div>
              <div class="panel-meta">
                <span>Active Card: <strong id="binaryActiveLabel">--</strong></span>
                <span>Flips Left: <strong id="binaryFlipInfo">1</strong></span>
              </div>
              <div class="button-row">
                <button class="launch" id="binaryStart">Deal Hand</button>
                <button class="cashout" id="binaryLock" disabled>Lock In</button>
              </div>
              <div class="status" id="binaryStatus">Set your wager and deal a binary hand.</div>
            </aside>
          </div>
        </div>
      </div>
    </section>
  </main>
</div>

    <script>
      // ---------------- Configurable parameters ----------------
      const settings = {
        startingBalance: 1000,
        tickInterval: 60,
        maxMultiplier: 100,
        rocketArc: {
          floorX: 8, // percentage from left
          ceilingX: 88,
          floorY: 18, // percentage from bottom
          ceilingY: 36,
        },
        dangerDistance: 0.6,
        resetDelay: 1700,
      };

      // ---------------- Shared state ----------------
      let balance = settings.startingBalance;
      const historyItems = [];

      // ---------------- Rocket state ----------------
      let currentBet = 0;
      let multiplier = 1;
      let explosionPoint = 0;
      let flightInterval = null;
      let ticks = 0;
      let inFlight = false;
      let cashedOut = false;

      // ---------------- Pulse state ----------------
      let pulseBet = 0;
      let pulseMultiplier = 1;
      let pulseExplosionPoint = 0;
      let pulseTicks = 0;
      let pulseRunning = false;
      let pulseFrame = null;
      let pulseCashedOut = false;

      // ---------------- Mind Bet state ----------------
      let mindBet = 0;
      let mindMultiplier = 1;
      let mindThreshold = 0;
      let mindRunning = false;
      let mindCashedOut = false;
      let mindFrame = null;
      let mindMoodInterval = null;
      let mindLastTick = 0;
      let mindMoodScore = 0;

      let pathLength = 1;
      let activeMode = 'rocket';
      let activeSection = 'skill';
      let activeCardGame = null;

      // ---------------- Binary Poker state ----------------
      let binaryRunning = false;
      let binaryBet = 0;
      let binaryCards = [];
      let binaryTarget = '';
      let binaryActiveCard = 0;
      let binaryFlipsLeft = 0;
      let binaryLastFlip = null;

      // ---------------- Elements ----------------
      const baseTitle = 'NeonArc Casino';
      const titleEl = document.getElementById('sectionTitle');
      const balanceEl = document.getElementById('balance');
      const sectionButtons = document.querySelectorAll('.section-button');
      const modeButtons = document.querySelectorAll('.mode-button');
      const sections = {
        skill: document.getElementById('skillGamesSection'),
        card: document.getElementById('cardGamesSection'),
      };
      const panels = {
        rocket: document.getElementById('rocketMode'),
        pulse: document.getElementById('pulseMode'),
        mind: document.getElementById('mindMode'),
      };

      const cardLobby = document.getElementById('cardLobby');
      const cardTiles = document.querySelectorAll('.card-game-tile');
      const cardBackBtn = document.getElementById('cardBackBtn');
      const binaryGamePanel = document.getElementById('binaryPokerGame');
      const cardPanels = {
        binaryPoker: binaryGamePanel,
      };

      const binaryStage = document.getElementById('binaryStage');
      const binaryHandEl = document.getElementById('binaryHand');
      const binaryTargetEl = document.getElementById('binaryTarget');
      const binaryBetInput = document.getElementById('binaryBet');
      const binaryStartBtn = document.getElementById('binaryStart');
      const binaryLockBtn = document.getElementById('binaryLock');
      const binaryStatusEl = document.getElementById('binaryStatus');
      const binaryActiveLabel = document.getElementById('binaryActiveLabel');
      const binaryFlipInfo = document.getElementById('binaryFlipInfo');

      // Rocket elements
      const betInput = document.getElementById('bet');
      const riskTag = document.getElementById('riskTag');
      const riskCopy = document.getElementById('riskCopy');
      const roundTag = document.getElementById('roundTag');
      const launchBtn = document.getElementById('launchBtn');
      const cashBtn = document.getElementById('cashOutBtn');
      const statusEl = document.getElementById('status');
      const multiplierEl = document.getElementById('multiplier');
      const resultEl = document.getElementById('roundResult');
      const potentialEl = document.getElementById('potential');
      const rocketStage = document.getElementById('rocketStage');
      const rocketSprite = document.getElementById('rocket');
      const historyList = document.getElementById('history');
      const pulseHistoryList = document.getElementById('pulseHistory');
      const pathProgress = document.getElementById('pathProgress');
      const trackGlow = document.getElementById('rocketTrackGlow');

      // Pulse elements
      const pulseBetInput = document.getElementById('pulseBet');
      const pulseRiskTag = document.getElementById('pulseRiskTag');
      const pulseRiskCopy = document.getElementById('pulseRiskCopy');
      const pulseRoundTag = document.getElementById('pulseRoundTag');
      const pulseLaunchBtn = document.getElementById('pulseLaunchBtn');
      const pulseCashBtn = document.getElementById('pulseCashBtn');
      const pulseStatusEl = document.getElementById('pulseStatus');
      const pulseMultiplierEl = document.getElementById('pulseMultiplier');
      const pulseResultEl = document.getElementById('pulseRoundResult');
      const pulsePotentialEl = document.getElementById('pulsePotential');
      const pulseStage = document.getElementById('pulseStage');
      const pulseLine = document.getElementById('pulseLine');
      const pulseGlow = document.getElementById('pulseGlow');

      // Mind elements
      const mindBetInput = document.getElementById('mindBet');
      const mindSignalTag = document.getElementById('mindSignalTag');
      const mindRoundTag = document.getElementById('mindRoundTag');
      const mindInsight = document.getElementById('mindInsight');
      const mindStartBtn = document.getElementById('mindStartBtn');
      const mindCashBtn = document.getElementById('mindCashBtn');
      const mindStatusEl = document.getElementById('mindStatus');
      const mindStage = document.getElementById('mindStage');
      const mindMultiplierEl = document.getElementById('mindMultiplier');
      const mindResultEl = document.getElementById('mindRoundResult');
      const mindPotentialEl = document.getElementById('mindPotential');
      const mindMoodLabel = document.getElementById('mindMood');
      const mindEmotionEl = document.getElementById('aiEmotion');
      const mindHistoryList = document.getElementById('mindHistory');

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      function init() {
        pathLength = pathProgress.getTotalLength();
        pathProgress.style.strokeDasharray = pathLength;
        pathProgress.style.strokeDashoffset = pathLength;
        document.documentElement.style.setProperty('--progress', '0');
        document.documentElement.style.setProperty('--stage-hue', '210');
        document.documentElement.style.setProperty('--glow-strength', '0.2');
        trackGlow.style.opacity = '0.15';
        rocketSprite.style.left = `${settings.rocketArc.floorX}%`;
        rocketSprite.style.bottom = `${settings.rocketArc.floorY}%`;
        rocketSprite.style.transform = 'translate(-50%, 0) rotate(-6deg)';
        updateBalance();
        updateRiskMessaging();
        populateHistory();
        roundTag.textContent = 'Idle';
        resetPulseGame(true);
        updatePulseRiskMessaging();
        resetMindGame(true);
        updateMindInsight();
        resetBinaryPoker(true);
        setTitle('Rocket Line');

        sectionButtons.forEach((button) => {
          button.addEventListener('click', () => switchSection(button.dataset.section));
        });
        modeButtons.forEach((button) => {
          button.addEventListener('click', () => switchMode(button.dataset.mode));
        });
        cardTiles.forEach((tile) => {
          if (tile.disabled) return;
          tile.addEventListener('click', () => {
            if (activeSection !== 'card') {
              switchSection('card');
            }
            enterCardGame(tile.dataset.game);
          });
        });
        cardBackBtn.addEventListener('click', () => exitCardGame());
        binaryStartBtn.addEventListener('click', startBinaryPoker);
        binaryLockBtn.addEventListener('click', finishBinaryPoker);
        binaryHandEl.addEventListener('click', handleBinaryHandClick);
        launchBtn.addEventListener('click', launchRocket);
        cashBtn.addEventListener('click', cashOut);
        betInput.addEventListener('input', updateRiskMessaging);
        pulseLaunchBtn.addEventListener('click', startPulseCash);
        pulseCashBtn.addEventListener('click', cashOutPulse);
        pulseBetInput.addEventListener('input', updatePulseRiskMessaging);
        mindStartBtn.addEventListener('click', startMindBet);
        mindCashBtn.addEventListener('click', cashOutMindBet);
        mindBetInput.addEventListener('input', updateMindInsight);
      }

      // ---------------- Shared helpers ----------------
      function updateBalance() {
        balanceEl.textContent = balance.toLocaleString(undefined, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        });
      }

      function switchMode(mode) {
        if (mode === activeMode) return;
        if (mindRunning && mode !== 'mind') {
          setMindStatus('Stay focused‚Äîcash out or ride the thought to the end.');
          return;
        }
        if (mode === 'pulse' && inFlight) {
          setStatus('Finish the rocket round before switching modes.');
          return;
        }
        if (mode === 'rocket' && pulseRunning) {
          setPulseStatus('Stabilize this pulse before changing modes.');
          return;
        }
        if (mode === 'mind') {
          if (inFlight) {
            setStatus('Finish the rocket round before linking with the mind.');
            return;
          }
          if (pulseRunning) {
            setPulseStatus('Calm the pulse before opening the mind link.');
            return;
          }
        }

        activeMode = mode;
        Object.entries(panels).forEach(([key, panel]) => {
          panel.classList.toggle('active', key === mode);
        });
        modeButtons.forEach((button) => {
          button.classList.toggle('active', button.dataset.mode === mode);
        });
        const titles = {
          rocket: 'Rocket Line',
          pulse: 'Pulse Cash',
          mind: 'Mind Bet',
        };
        if (activeSection === 'skill') {
          setTitle(titles[mode] || 'Skill Games');
        }
      }

      function recordHistory(win, value) {
        historyItems.unshift({ win, value: value.toFixed(2) });
        if (historyItems.length > 4) historyItems.pop();
        populateHistory();
      }

      function populateHistory() {
        const lists = [historyList, pulseHistoryList, mindHistoryList];
        lists.forEach((list) => {
          if (!list) return;
          list.innerHTML = '';
          for (let i = 0; i < 4; i += 1) {
            const item = historyItems[i];
            const li = document.createElement('li');
            if (item) {
              li.className = item.win ? 'win' : 'loss';
              li.textContent = `${item.win ? 'Win' : 'Bust'} @ ${item.value}x`;
            } else {
              li.className = 'placeholder';
              li.textContent = '--';
            }
            list.appendChild(li);
          }
        });
      }

      function randRange(min, max) {
        return parseFloat((Math.random() * (max - min) + min).toFixed(2));
      }

      function setTitle(suffix) {
        if (!titleEl) return;
        titleEl.textContent = suffix ? `${baseTitle} ¬∑ ${suffix}` : baseTitle;
      }

      function switchSection(sectionName) {
        if (!sections[sectionName]) return false;
        if (sectionName === activeSection) return true;
        if (sectionName === 'card') {
          if (inFlight) {
            setStatus('Finish the rocket round before changing sections.');
            return false;
          }
          if (pulseRunning) {
            setPulseStatus('Stabilize this pulse before changing sections.');
            return false;
          }
          if (mindRunning) {
            setMindStatus('Resolve the mind link before changing sections.');
            return false;
          }
        } else if (sectionName === 'skill') {
          if (binaryRunning) {
            setBinaryStatus('Resolve your Binary Poker hand before leaving.');
            return false;
          }
        }

        activeSection = sectionName;
        Object.entries(sections).forEach(([key, panel]) => {
          panel.classList.toggle('active', key === sectionName);
        });
        sectionButtons.forEach((button) => {
          button.classList.toggle('active', button.dataset.section === sectionName);
        });

        if (sectionName === 'skill') {
          exitCardGame(false);
          const titles = {
            rocket: 'Rocket Line',
            pulse: 'Pulse Cash',
            mind: 'Mind Bet',
          };
          setTitle(titles[activeMode] || 'Skill Games');
        } else if (sectionName === 'card') {
          if (!activeCardGame) {
            cardLobby.classList.add('active');
            Object.values(cardPanels).forEach((panel) => panel.classList.remove('active'));
          }
          setTitle(activeCardGame === 'binaryPoker' ? 'Binary Poker' : 'Card Games Lobby');
        }

        return true;
      }

      function enterCardGame(gameName) {
        if (!gameName) return;
        if (activeSection !== 'card') {
          const switched = switchSection('card');
          if (!switched) return;
        }
        if (gameName === activeCardGame) return;
        cardLobby.classList.remove('active');
        Object.values(cardPanels).forEach((panel) => panel.classList.remove('active'));
        const targetPanel = cardPanels[gameName];
        if (targetPanel) {
          targetPanel.classList.add('active');
        }
        activeCardGame = gameName;
        if (gameName === 'binaryPoker') {
          resetBinaryPoker(true);
          setTitle('Binary Poker');
        }
      }

      function exitCardGame(manual = true) {
        if (binaryRunning) {
          setBinaryStatus('Resolve your Binary Poker hand before leaving.');
          return false;
        }
        Object.values(cardPanels).forEach((panel) => panel.classList.remove('active'));
        cardLobby.classList.add('active');
        activeCardGame = null;
        resetBinaryPoker(!manual);
        if (manual || activeSection === 'card') {
          setTitle('Card Games Lobby');
        }
        return true;
      }

      function startBinaryPoker() {
        if (binaryRunning) return;
        const wager = Math.floor(Number(binaryBetInput.value));
        if (!wager || wager <= 0) {
          setBinaryStatus('Enter a valid bet to deal.');
          return;
        }
        if (wager > balance) {
          setBinaryStatus('Insufficient balance for that wager.');
          return;
        }

        binaryBet = wager;
        balance -= binaryBet;
        updateBalance();

        binaryRunning = true;
        binaryFlipsLeft = 1;
        binaryCards = Array.from({ length: 5 }, () => randomBinaryCard());
        binaryTarget = randomBinaryCard();
        binaryActiveCard = 0;
        binaryLastFlip = null;

        binaryStartBtn.disabled = true;
        binaryLockBtn.disabled = false;
        binaryBetInput.disabled = true;
        binaryActiveLabel.textContent = '1';
        binaryFlipInfo.textContent = binaryFlipsLeft.toString();
        binaryTargetEl.textContent = 'Target encoded. Flip a bit or lock in.';
        setBinaryStatus('Hand dealt. Flip one bit or lock in your best binary card.');
        binaryStage.classList.add('live');
        binaryStage.classList.remove('idle');
        renderBinaryCards();
      }

      function handleBinaryHandClick(event) {
        const bitEl = event.target.closest('.binary-bit');
        if (bitEl) {
          const cardIndex = Number(bitEl.dataset.card);
          const bitIndex = Number(bitEl.dataset.bit);
          if (!binaryRunning) return;
          if (Number.isNaN(cardIndex) || Number.isNaN(bitIndex)) return;
          if (cardIndex !== binaryActiveCard) {
            setBinaryStatus('Select that card before flipping its bits.');
            return;
          }
          flipBit(bitIndex);
          return;
        }

        const cardEl = event.target.closest('.binary-card');
        if (!cardEl || cardEl.classList.contains('placeholder')) return;
        const cardIndex = Number(cardEl.dataset.card);
        if (Number.isNaN(cardIndex)) return;
        selectBinaryCard(cardIndex);
      }

      function selectBinaryCard(index) {
        if (!binaryCards.length) return;
        binaryActiveCard = Math.max(0, Math.min(index, binaryCards.length - 1));
        binaryActiveLabel.textContent = `${binaryActiveCard + 1}`;
        renderBinaryCards();
        if (binaryRunning) {
          const prompt =
            binaryFlipsLeft > 0 ? 'You may flip one bit on this card.' : 'No flips remaining ‚Äî lock in when ready.';
          setBinaryStatus(`Card ${binaryActiveCard + 1} selected. ${prompt}`);
        }
      }

      function renderBinaryCards() {
        binaryHandEl.innerHTML = '';
        if (!binaryCards.length) {
          const placeholder = document.createElement('div');
          placeholder.className = 'binary-placeholder';
          placeholder.textContent = 'Deal a hand to reveal five binary cards.';
          binaryHandEl.appendChild(placeholder);
          return;
        }

        binaryCards.forEach((bits, cardIndex) => {
          const cardButton = document.createElement('button');
          cardButton.type = 'button';
          cardButton.className = 'binary-card';
          cardButton.dataset.card = cardIndex.toString();
          if (cardIndex === binaryActiveCard) {
            cardButton.classList.add('active');
          }

          const label = document.createElement('div');
          label.className = 'binary-label';
          label.textContent = `Card ${cardIndex + 1}`;

          const value = document.createElement('div');
          value.className = 'binary-value';
          value.textContent = parseInt(bits, 2).toString();

          const bitGrid = document.createElement('div');
          bitGrid.className = 'binary-bits';
          bits.split('').forEach((bit, bitIndex) => {
            const bitSpan = document.createElement('span');
            bitSpan.className = 'binary-bit';
            if (
              binaryLastFlip &&
              binaryLastFlip.card === cardIndex &&
              binaryLastFlip.bit === bitIndex
            ) {
              bitSpan.classList.add('flipped');
            }
            bitSpan.dataset.card = cardIndex.toString();
            bitSpan.dataset.bit = bitIndex.toString();
            bitSpan.textContent = bit;
            bitGrid.appendChild(bitSpan);
          });

          cardButton.appendChild(label);
          cardButton.appendChild(value);
          cardButton.appendChild(bitGrid);
          binaryHandEl.appendChild(cardButton);
        });
      }

      function flipBit(bitIndex) {
        if (!binaryRunning) {
          setBinaryStatus('Deal a hand before flipping bits.');
          return;
        }
        if (binaryFlipsLeft <= 0) {
          setBinaryStatus('No flips remaining this round.');
          return;
        }
        if (bitIndex < 0 || bitIndex >= 4) return;

        const bits = binaryCards[binaryActiveCard].split('');
        bits[bitIndex] = bits[bitIndex] === '0' ? '1' : '0';
        binaryCards[binaryActiveCard] = bits.join('');
        binaryFlipsLeft -= 1;
        binaryLastFlip = { card: binaryActiveCard, bit: bitIndex };
        binaryFlipInfo.textContent = binaryFlipsLeft.toString();
        setBinaryStatus('Bit flipped. Lock in when ready.');
        renderBinaryCards();
      }

      function finishBinaryPoker() {
        if (!binaryRunning) {
          setBinaryStatus('Deal a hand before locking in.');
          return;
        }

        binaryRunning = false;
        binaryStartBtn.disabled = false;
        binaryLockBtn.disabled = true;
        binaryBetInput.disabled = false;
        binaryStage.classList.remove('live');
        binaryStage.classList.add('idle');

        const playerBits = binaryCards[binaryActiveCard];
        const targetBits = binaryTarget;
        const distance = getHammingDistance(playerBits, targetBits);
        const numericDiff = Math.abs(parseInt(playerBits, 2) - parseInt(targetBits, 2));
        const payoutTable = {
          0: 4,
          1: 2.5,
          2: 1.4,
          3: 0,
          4: 0,
        };
        const multiplierWin = payoutTable[distance] ?? 0;
        let winnings = 0;

        if (multiplierWin > 0) {
          winnings = binaryBet * multiplierWin;
          balance += winnings;
          updateBalance();
          setBinaryStatus(
            `Distance ${distance}. Payout ${multiplierWin.toFixed(2)}x = $${winnings.toFixed(2)}.`
          );
        } else {
          setBinaryStatus(`Distance ${distance}. Bet lost.`);
        }

        binaryTargetEl.textContent = `Target ${targetBits} ¬∑ Your ${playerBits} ¬∑ Œî${numericDiff} | Distance ${distance}`;
        binaryFlipInfo.textContent = '0';
        binaryBet = 0;
      }

      function resetBinaryPoker(initial) {
        binaryRunning = false;
        binaryBet = 0;
        binaryCards = [];
        binaryTarget = '';
        binaryActiveCard = 0;
        binaryFlipsLeft = 0;
        binaryLastFlip = null;
        binaryStartBtn.disabled = false;
        binaryLockBtn.disabled = true;
        binaryBetInput.disabled = false;
        binaryActiveLabel.textContent = '--';
        binaryFlipInfo.textContent = '1';
        binaryStage.classList.remove('live');
        binaryStage.classList.add('idle');
        renderBinaryCards();
        binaryTargetEl.textContent = 'Target encoded. Flip a bit or lock in.';
        if (initial) {
          setBinaryStatus('Set your wager and deal a binary hand.');
        } else {
          setBinaryStatus('Hand reset. Ready for a new deal.');
        }
      }

      function setBinaryStatus(message) {
        binaryStatusEl.textContent = message;
      }

      function randomBinaryCard() {
        return Array.from({ length: 4 }, () => (Math.random() < 0.5 ? '0' : '1')).join('');
      }

      function getHammingDistance(a, b) {
        const maxLength = Math.min(a.length, b.length);
        let distance = 0;
        for (let i = 0; i < maxLength; i += 1) {
          if (a[i] !== b[i]) distance += 1;
        }
        return distance + Math.abs(a.length - b.length);
      }

      // ---------------- Rocket mode ----------------
      function updateRiskMessaging() {
        const bet = Number(betInput.value) || 0;
        if (bet >= 50) {
          riskTag.textContent = 'Severe';
          riskCopy.textContent = 'Large wagers put the rocket on edge. Expect abrupt failures between 1x and 5x, with only rare surges above.';
        } else if (bet >= 10) {
          riskTag.textContent = 'Pressured';
          riskCopy.textContent = 'Mid-range stakes tighten the climb. Cash outs beyond 20x are uncommon‚Äîtime your exit.';
        } else if (bet > 0) {
          riskTag.textContent = 'Balanced';
          riskCopy.textContent = 'Smaller stakes enjoy broader ceilings. Massive multipliers remain elusive but possible.';
        } else {
          riskTag.textContent = '--';
          riskCopy.textContent = '';
        }
      }

      function launchRocket() {
        if (inFlight) return;
        const bet = Math.floor(Number(betInput.value));
        if (!bet || bet <= 0) {
          setStatus('Enter a valid bet to begin.');
          return;
        }
        if (bet > balance) {
          setStatus('Insufficient balance for that wager.');
          return;
        }

        currentBet = bet;
        balance -= currentBet;
        updateBalance();

        multiplier = 1;
        ticks = 0;
        cashedOut = false;
        explosionPoint = getExplosionPoint(currentBet);
        inFlight = true;

        rocketStage.classList.remove('idle', 'exploded', 'danger');
        launchBtn.disabled = true;
        cashBtn.disabled = false;
        betInput.disabled = true;
        roundTag.textContent = 'Live';
        setStatus('Hold steady...');
        resultEl.classList.remove('win', 'loss');
        resultEl.textContent = 'In flight ‚Äî watch the line!';
        updateRocketDisplays();

        flightInterval = setInterval(updateFlight, settings.tickInterval);
      }

      function updateFlight() {
        ticks += 1;
        const accel = Math.min(0.008 + ticks / 1400, 0.17);
        multiplier += multiplier * accel;
        updateRocketDisplays();
        updateRocketPath();
        updateStageHue();
        flagRocketDanger();

        if (multiplier >= explosionPoint) {
          explodeRocket();
        }
      }

      function updateRocketDisplays() {
        const rounded = multiplier.toFixed(2);
        multiplierEl.textContent = `${rounded}x`;
        if (inFlight) {
          const potential = currentBet * multiplier;
          potentialEl.textContent = `Potential: $${potential.toFixed(2)}`;
        } else {
          potentialEl.textContent = 'Potential: $0.00';
        }
      }

      function updateRocketPath() {
        const riseFactor = Math.max(multiplier - 1, 0);
        const normalized = Math.pow(Math.min(riseFactor / 8, 1), 0.58);
        const clamped = Math.max(0, Math.min(normalized, 1));
        const xPercent =
          settings.rocketArc.floorX + (settings.rocketArc.ceilingX - settings.rocketArc.floorX) * clamped;
        const baseY =
          settings.rocketArc.floorY + (settings.rocketArc.ceilingY - settings.rocketArc.floorY) * Math.pow(clamped, 1.25);
        rocketSprite.style.left = `${xPercent}%`;
        rocketSprite.style.bottom = `${baseY}%`;
        rocketSprite.style.transform = `translate(-50%, 0) rotate(${clamped * 12 - 6}deg)`;

        const progress = clamped;
        document.documentElement.style.setProperty('--progress', progress.toString());
        pathProgress.style.strokeDashoffset = pathLength * (1 - progress);
        trackGlow.style.opacity = Math.max(0.15, progress * 0.8).toString();
        document.documentElement.style.setProperty('--glow-strength', (0.1 + progress * 0.45).toFixed(3));
      }

      function updateStageHue() {
        const hueShift = Math.max(160, 210 - multiplier * 2.3);
        document.documentElement.style.setProperty('--stage-hue', hueShift.toFixed(1));
      }

      function flagRocketDanger() {
        if (explosionPoint - multiplier <= settings.dangerDistance) {
          rocketStage.classList.add('danger');
        }
      }

      function cashOut() {
        if (!inFlight || cashedOut) return;
        cashedOut = true;
        const winnings = currentBet * multiplier;
        balance += winnings;
        updateBalance();

        setStatus(`You bailed at ${multiplier.toFixed(2)}x for $${winnings.toFixed(2)}.`);
        resultEl.classList.remove('loss');
        resultEl.classList.add('win');
        resultEl.textContent = `Won = $${winnings.toFixed(2)}`;
        roundTag.textContent = 'Cashed Out';
        recordHistory(true, multiplier);
        endFlight();
        scheduleReset();
      }

      function explodeRocket() {
        if (!inFlight) return;
        rocketStage.classList.add('exploded');
        setStatus(`Explosion at ${explosionPoint.toFixed(2)}x. Bet lost.`);
        resultEl.classList.remove('win');
        resultEl.classList.add('loss');
        resultEl.textContent = 'Busted ‚Äî bet lost.';
        roundTag.textContent = 'Busted';
        recordHistory(false, explosionPoint);
        endFlight();
        scheduleReset();
      }

      function endFlight() {
        clearInterval(flightInterval);
        flightInterval = null;
        inFlight = false;
        cashBtn.disabled = true;
      }

      function scheduleReset() {
        setTimeout(resetGame, settings.resetDelay);
      }

      function resetGame() {
        multiplier = 1;
        updateRocketDisplays();
        document.documentElement.style.setProperty('--progress', '0');
        document.documentElement.style.setProperty('--stage-hue', '210');
        document.documentElement.style.setProperty('--glow-strength', '0.2');
        pathProgress.style.strokeDashoffset = pathLength;
        rocketStage.classList.remove('danger');
        rocketStage.classList.remove('exploded');
        rocketStage.classList.add('idle');
        rocketSprite.style.left = `${settings.rocketArc.floorX}%`;
        rocketSprite.style.bottom = `${settings.rocketArc.floorY}%`;
        rocketSprite.style.transform = 'translate(-50%, 0) rotate(-6deg)';
        potentialEl.textContent = 'Potential: $0.00';
        roundTag.textContent = 'Idle';
        launchBtn.disabled = false;
        betInput.disabled = false;
        cashBtn.disabled = true;
        currentBet = 0;
        resultEl.classList.remove('win', 'loss');
        resultEl.textContent = 'Enter a bet to play.';
        setStatus('Rocket idling on the pad.');
        cashedOut = false;
      }

      function getExplosionPoint(bet) {
        const roll = Math.random();
        if (bet < 10) {
          if (roll < 0.6) return randRange(1, 12);
          if (roll < 0.85) return randRange(12, 25);
          if (roll < 0.95) return randRange(25, 50);
          return randRange(50, settings.maxMultiplier);
        }
        if (bet <= 50) {
          if (roll < 0.7) return randRange(1, 12);
          if (roll < 0.9) return randRange(12, 20);
          return randRange(20, 60);
        }
        if (roll < 0.8) return randRange(1, 5);
        if (roll < 0.95) return randRange(5, 12);
        return randRange(12, 40);
      }

      function setStatus(message) {
        statusEl.textContent = message;
      }

      // ---------------- Pulse Cash mode ----------------
      function updatePulseRiskMessaging() {
        const bet = Number(pulseBetInput.value) || 0;
        if (bet > 50) {
          pulseRiskTag.textContent = 'Volatile';
          pulseRiskCopy.textContent = 'Huge stakes overload containment. Expect quick breaks between 1x and 10x, with only fleeting bursts above.';
        } else if (bet >= 10) {
          pulseRiskTag.textContent = 'Tense';
          pulseRiskCopy.textContent = 'Containment favors short runs near 1x‚Äì25x. Watch the line and cash out early.';
        } else if (bet > 0) {
          pulseRiskTag.textContent = 'Balanced';
          pulseRiskCopy.textContent = 'Light pulses drift calmly. Full 1x‚Äì100x climbs stay within reach if luck holds.';
        } else {
          pulseRiskTag.textContent = '--';
          pulseRiskCopy.textContent = '';
        }
      }

      function startPulseCash() {
        if (pulseRunning) return;
        const bet = Math.floor(Number(pulseBetInput.value));
        if (!bet || bet <= 0) {
          setPulseStatus('Enter a valid bet to begin.');
          return;
        }
        if (bet > balance) {
          setPulseStatus('Insufficient balance for that wager.');
          return;
        }

        pulseBet = bet;
        balance -= pulseBet;
        updateBalance();

        pulseMultiplier = 1;
        pulseTicks = 0;
        pulseCashedOut = false;
        pulseExplosionPoint = getPulseExplosionPoint(pulseBet);
        pulseRunning = true;

        pulseStage.classList.remove('idle', 'overloaded', 'exploded');
        pulseStage.classList.add('live');
        pulseLaunchBtn.disabled = true;
        pulseCashBtn.disabled = false;
        pulseBetInput.disabled = true;
        pulseRoundTag.textContent = 'Live';
        pulseResultEl.classList.remove('win', 'loss');
        pulseResultEl.textContent = 'Pulse climbing...';
        setPulseStatus('Ride the surge and cash before overload.');
        updatePulseDisplays();
        setPulseTrackProgress(0);

        pulseFrame = requestAnimationFrame(stepPulse);
      }

      function stepPulse() {
        if (!pulseRunning) return;
        pulseTicks += 1;
        const accel = Math.min(0.01 + pulseTicks / 1600, 0.16);
        pulseMultiplier += pulseMultiplier * accel;
        updatePulseDisplays();
        updatePulseTrack();

        if (pulseMultiplier >= pulseExplosionPoint) {
          explodePulse();
          return;
        }

        pulseFrame = requestAnimationFrame(stepPulse);
      }

      function updatePulseDisplays() {
        const rounded = pulseMultiplier.toFixed(2);
        pulseMultiplierEl.textContent = `${rounded}x`;
        if (pulseRunning) {
          const potential = pulseBet * pulseMultiplier;
          pulsePotentialEl.textContent = `Potential: $${potential.toFixed(2)}`;
        } else {
          pulsePotentialEl.textContent = 'Potential: $0.00';
        }
      }

      function updatePulseTrack() {
        const riseFactor = Math.max(pulseMultiplier - 1, 0);
        const normalized = Math.pow(Math.min(riseFactor / 12, 1), 0.6);
        setPulseTrackProgress(normalized);
      }

      function setPulseTrackProgress(progress) {
        const clamped = Math.max(0, Math.min(progress, 1));
        const offset = 4 + clamped * 92;
        pulseLine.style.left = `${offset}%`;
        pulseGlow.style.left = `${offset}%`;
        pulseGlow.style.opacity = (0.2 + clamped * 0.55).toFixed(2);
        pulseGlow.style.transform = `translate(-50%, -50%) scale(${1 + clamped * 0.45})`;
        pulseStage.style.setProperty('--pulse-progress', clamped.toString());
      }

      function cashOutPulse() {
        if (!pulseRunning || pulseCashedOut) return;
        pulseCashedOut = true;
        const winnings = pulseBet * pulseMultiplier;
        balance += winnings;
        updateBalance();

        setPulseStatus(`Cashed at ${pulseMultiplier.toFixed(2)}x for $${winnings.toFixed(2)}.`);
        pulseResultEl.classList.remove('loss');
        pulseResultEl.classList.add('win');
        pulseResultEl.textContent = `Won = $${winnings.toFixed(2)}`;
        pulseRoundTag.textContent = 'Cashed Out';
        recordHistory(true, pulseMultiplier);
        endPulse();
        schedulePulseReset();
      }

      function explodePulse() {
        if (!pulseRunning) return;
        pulseStage.classList.add('overloaded', 'exploded');
        setPulseStatus(`Overload at ${pulseExplosionPoint.toFixed(2)}x. Bet lost.`);
        pulseResultEl.classList.remove('win');
        pulseResultEl.classList.add('loss');
        pulseResultEl.textContent = 'Core overloaded ‚Äî bet lost.';
        pulseRoundTag.textContent = 'Busted';
        recordHistory(false, pulseExplosionPoint);
        endPulse();
        schedulePulseReset();
      }

      function endPulse() {
        if (pulseFrame) {
          cancelAnimationFrame(pulseFrame);
          pulseFrame = null;
        }
        pulseRunning = false;
        pulseCashBtn.disabled = true;
      }

      function schedulePulseReset() {
        setTimeout(() => resetPulseGame(false), settings.resetDelay);
      }

      function resetPulseGame(initial) {
        pulseMultiplier = 1;
        pulseTicks = 0;
        pulseBet = 0;
        pulseCashedOut = false;
        pulseRunning = false;
        updatePulseDisplays();
        setPulseTrackProgress(0);
        pulseStage.classList.remove('live', 'overloaded', 'exploded');
        pulseStage.classList.add('idle');
        pulseLaunchBtn.disabled = false;
        pulseCashBtn.disabled = true;
        pulseBetInput.disabled = false;
        pulseResultEl.classList.remove('win', 'loss');
        pulseResultEl.textContent = 'Enter a bet to play.';
        pulseRoundTag.textContent = 'Idle';
        pulsePotentialEl.textContent = 'Potential: $0.00';
        updatePulseRiskMessaging();
        if (initial) {
          pulseStatusEl.textContent = 'Pulse core stable.';
        } else {
          setPulseStatus('Pulse core stable.');
        }
      }

      function setPulseStatus(message) {
        pulseStatusEl.textContent = message;
      }

      function getPulseExplosionPoint(bet) {
        const roll = Math.random();
        if (bet < 10) {
          if (roll < 0.5) return randRange(1, 15);
          if (roll < 0.8) return randRange(15, 40);
          if (roll < 0.95) return randRange(40, 70);
          return randRange(70, 100);
        }
        if (bet <= 50) {
          if (roll < 0.6) return randRange(1, 10);
          if (roll < 0.85) return randRange(10, 20);
          if (roll < 0.97) return randRange(20, 35);
          return randRange(35, 60);
        }
        if (roll < 0.75) return randRange(1, 6);
        if (roll < 0.92) return randRange(6, 12);
        if (roll < 0.985) return randRange(12, 18);
        return randRange(18, 35);
      }

      // ---------------- Mind Bet mode ----------------
      function updateMindInsight() {
        const bet = Number(mindBetInput.value) || 0;
        if (bet >= 75) {
          mindSignalTag.textContent = 'Erratic';
          mindInsight.textContent = 'Heavy stakes overload the AI focus. Expect sharp flips between 1x and 5x with rare surges beyond.';
        } else if (bet >= 25) {
          mindSignalTag.textContent = 'Wary';
          mindInsight.textContent = 'Mid stakes agitate the interface. Multipliers commonly stall around 1x‚Äì20x before a mind shift.';
        } else if (bet > 0) {
          mindSignalTag.textContent = 'Aligned';
          mindInsight.textContent = 'Light wagers keep the link composed. Long meditations up to 100x are possible if luck holds.';
        } else {
          mindSignalTag.textContent = '--';
          mindInsight.textContent = '';
        }
      }

      function startMindBet() {
        if (mindRunning) return;
        const bet = Math.floor(Number(mindBetInput.value));
        if (!bet || bet <= 0) {
          setMindStatus('Enter a valid bet to open the mind link.');
          return;
        }
        if (bet > balance) {
          setMindStatus('Insufficient balance for that wager.');
          return;
        }

        mindBet = bet;
        balance -= mindBet;
        updateBalance();

        mindMultiplier = 1;
        mindThreshold = randRange(1, settings.maxMultiplier);
        mindRunning = true;
        mindCashedOut = false;
        mindLastTick = performance.now();

        mindStage.classList.remove('idle', 'exploded', 'near-flip');
        mindStage.classList.add('live');
        mindRoundTag.textContent = 'Live';
        mindResultEl.classList.remove('win', 'loss');
        mindResultEl.textContent = 'Link live ‚Äî watch the intent.';
        mindStartBtn.disabled = true;
        mindCashBtn.disabled = false;
        mindBetInput.disabled = true;
        setMindStatus('Link open‚Äîtrust the signals, but act fast.');
        updateMindDisplays();
        mindMoodScore = Math.floor(Math.random() * 101);
        applyMindMood(mindMoodScore);

        if (mindFrame) cancelAnimationFrame(mindFrame);
        mindFrame = requestAnimationFrame(stepMindBet);
        if (mindMoodInterval) clearInterval(mindMoodInterval);
        mindMoodInterval = setInterval(updateMindMood, 1000);
      }

      function stepMindBet(timestamp) {
        if (!mindRunning) return;
        const delta = Math.max((timestamp - mindLastTick) / 1000, 0.016);
        mindLastTick = timestamp;

        const acceleration = 0.85 + mindMultiplier * 0.18;
        mindMultiplier += acceleration * delta;
        updateMindDisplays();

        const ratio = mindThreshold ? mindMultiplier / mindThreshold : 0;
        const hazardBase = Math.pow(Math.max(ratio, 0), 1.8) * 0.28;
        const extendedRisk = Math.max(0, mindMultiplier - 20) * 0.0025;
        const erraticBoost = mindMoodScore >= 90 ? 0.12 : mindMoodScore >= 70 ? 0.05 : 0;
        const crashChance = Math.min(0.55, hazardBase + extendedRisk + erraticBoost);

        mindStage.classList.toggle('near-flip', ratio >= 0.82 || mindMoodScore >= 90);

        if (Math.random() < crashChance * delta) {
          explodeMindBet();
          return;
        }

        if (mindMultiplier >= mindThreshold) {
          explodeMindBet();
          return;
        }

        mindFrame = requestAnimationFrame(stepMindBet);
      }

      function updateMindDisplays() {
        mindMultiplierEl.textContent = `${mindMultiplier.toFixed(2)}x`;
        if (mindRunning) {
          const potential = mindBet * mindMultiplier;
          mindPotentialEl.textContent = `Potential: $${potential.toFixed(2)}`;
        } else {
          mindPotentialEl.textContent = 'Potential: $0.00';
        }
      }

      function updateMindMood() {
        if (!mindRunning) return;
        mindMoodScore = Math.floor(Math.random() * 101);
        applyMindMood(mindMoodScore);
      }

      function applyMindMood(score) {
        const moodClasses = ['mood-calm', 'mood-thinking', 'mood-worried', 'mood-erratic'];
        mindStage.classList.remove(...moodClasses);
        let emoji = 'üòå';
        let description = 'Calm ‚Äî signals stable.';
        let moodClass = 'mood-calm';
        if (score > 90) {
          emoji = 'üòµ';
          description = 'Erratic ‚Äî change of mind imminent!';
          moodClass = 'mood-erratic';
        } else if (score > 70) {
          emoji = 'üòü';
          description = 'Worried ‚Äî volatility rising.';
          moodClass = 'mood-worried';
        } else if (score > 40) {
          emoji = 'ü§î';
          description = 'Thinking ‚Äî reading your move.';
          moodClass = 'mood-thinking';
        }
        mindStage.classList.add(moodClass);
        mindEmotionEl.textContent = emoji;
        mindMoodLabel.textContent = description;
      }

      function cashOutMindBet() {
        if (!mindRunning || mindCashedOut) return;
        mindCashedOut = true;
        const winnings = mindBet * mindMultiplier;
        balance += winnings;
        updateBalance();

        setMindStatus(`Disconnected at ${mindMultiplier.toFixed(2)}x for $${winnings.toFixed(2)}.`);
        mindResultEl.classList.remove('loss');
        mindResultEl.classList.add('win');
        mindResultEl.textContent = `Won = $${winnings.toFixed(2)}`;
        mindRoundTag.textContent = 'Cashed Out';
        recordHistory(true, mindMultiplier);
        endMindBet();
        scheduleMindReset();
      }

      function explodeMindBet() {
        if (!mindRunning) return;
        mindStage.classList.add('exploded');
        const crashPoint = Math.min(mindMultiplier, mindThreshold);
        setMindStatus(`Mind flipped at ${crashPoint.toFixed(2)}x. Bet lost.`);
        mindResultEl.classList.remove('win');
        mindResultEl.classList.add('loss');
        mindResultEl.textContent = 'Mind changed ‚Äî bet lost.';
        mindRoundTag.textContent = 'Busted';
        recordHistory(false, crashPoint);
        endMindBet();
        scheduleMindReset();
      }

      function endMindBet() {
        if (mindFrame) {
          cancelAnimationFrame(mindFrame);
          mindFrame = null;
        }
        if (mindMoodInterval) {
          clearInterval(mindMoodInterval);
          mindMoodInterval = null;
        }
        mindRunning = false;
        mindCashBtn.disabled = true;
        mindStage.classList.remove('live', 'near-flip');
        mindStage.classList.add('idle');
        mindStage.classList.remove('mood-thinking', 'mood-worried', 'mood-erratic');
        mindStage.classList.add('mood-calm');
      }

      function scheduleMindReset() {
        setTimeout(() => resetMindGame(false), settings.resetDelay);
      }

      function resetMindGame(initial) {
        endMindBet();
        mindMultiplier = 1;
        mindBet = 0;
        mindThreshold = 0;
        mindCashedOut = false;
        mindMoodScore = 0;
        mindStage.classList.remove('live', 'exploded', 'near-flip', 'mood-thinking', 'mood-worried', 'mood-erratic');
        mindStage.classList.add('idle', 'mood-calm');
        mindMultiplierEl.textContent = '1.00x';
        mindPotentialEl.textContent = 'Potential: $0.00';
        mindResultEl.classList.remove('win', 'loss');
        mindResultEl.textContent = 'Sync a wager to begin.';
        mindRoundTag.textContent = 'Idle';
        mindMoodLabel.textContent = 'AI calm and observant.';
        mindEmotionEl.textContent = 'üòå';
        mindStartBtn.disabled = false;
        mindCashBtn.disabled = true;
        mindBetInput.disabled = false;
        updateMindInsight();
        if (initial) {
          mindStatusEl.textContent = 'Interface standing by.';
        } else {
          setMindStatus('Interface standing by.');
        }
      }

      function setMindStatus(message) {
        mindStatusEl.textContent = message;
      }
    </script>
  </body>
</html>
